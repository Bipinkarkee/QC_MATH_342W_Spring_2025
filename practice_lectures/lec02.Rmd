---
title: "Practice Lecture 2 MATH 342W Queens College"
author: "Professor Adam Kapelner"
date: "Jan 30, 2024"
---



# Convenient Mapping Function for Lists with the purrr package

We first load the library.

```{r}
pacman::p_load(purrr)
```

We will see later that the library `purrr` is part of a collection of libraries called the `tidyverse`.

Now imagine you have a collection of objects in a list. For example, let's let the object be matrices with different sizes:

```{r}
my_matrix_list = list()
my_matrix_list[["first"]] = matrix(rnorm(9), nrow = 3)
my_matrix_list[["second"]] = matrix(rnorm(12), nrow = 2)
my_matrix_list[["third"]] = matrix(rnorm(8), nrow = 4)
my_matrix_list
```

And you want to operate on each of those objects and return a list. Let's say I want to get back the dimensions, or the first rows, or the average values and return the same keys:

```{r}
my_dims_list = modify(my_matrix_list, ~ dim(.x))
my_dims_list
my_first_rows_list = modify(my_matrix_list, ~ .x[1, ])
my_first_rows_list
my_avgs_list = modify(my_matrix_list, ~ mean(.x))
my_avgs_list
```

This is a very convenient function known as "mapping" in functional programming. It saves a few lines of code e.g. the first `modify` would be:

```{r}
my_dims_list = list() #make new list to store keys --> dimensions of original matrices
for (key in names(my_matrix_list)){ #iterate over all list by key
  .x = my_matrix_list[[key]] #get value at the key for this iteration
  my_dims_list[[key]] = dim(.x) #run function on value and save it to new list
}
my_dims_list
```

The above which takes 5 lines and is repeated again and again and again in code all takes one line using the `modify` function. 

The `modify` function uses funky syntax which is not standard R. And it doesn't have to be; packages are allowed to extend the language and use symbols to create their own little mini-language. The `.x` above is a dummy variable for the value in the iteration in the imagined for loop (like in my rewritten boilerplate code above). The "~" tilde symbol we will be seeing in base R later on in class but in a completely different context. Here it just means "run the following function".

Modify is just one of the functions in the `purrr` package. See the following cheatsheet for more convenient functions: https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf.


## Loading datasets from R packages

Since R is a language built for data and statistics, it has a ton of interesting data sets by default and even more that are contained in packages. There is really just one command to know:

```{r}
rm(list = ls())
data(iris) #load the iris dataset (as a data frame). This dataset is included in the package "datasets" which is autoloaded by default
class(iris)
?iris
#3 things I always do immediately upon getting a dataset
head(iris)
str(iris)
summary(iris)
```

Here is another very famous dataset

```{r}
MASS::Boston #this just references the object but does not load it into the environment
data(Boston) #error since package MASS is not loaded by default
data(Boston, package = "MASS") #package argument not needed if package loaded 
head(Boston)
```

Most data sets are names some descriptive name like "loandata" or "cars". R has so many datasets. Here they all are by package installed:

```{r}
data(package = .packages(all.available = TRUE))
```


## Errors and Warnings

You can write better functions if you make use of errors and warnings. Java forces you to catch likely errors via the "throws" designation for a method but there is no such requirement in R.

* Errors are unrecoverable, they halt execution i.e. red lights
* Warnings (under usual execution) do not halt execution, but they display a message, i.e. yellow lights

Here's how they work:

```{r}
my_vector_sum = function(xs){
  
  if (!(class(xs) %in% c("numeric", "integer"))){ #short for class(xs) == "numeric" | class(xs) == "integer"
    stop("You need to pass in a vector of numbers not a vector of type \"", class(xs), "\".\n") #throw error!
    # warning("Your vector of type \"", class(xs), "\" will be coerced to numbers.\n") #throw warning!
    # xs = as.numeric(as.factor(xs))
  }
  
  tot = 0
  for (x in xs){
    tot = tot + x
  }
  tot
}
my_vector_sum(c(1, 2, 3))
my_vector_sum(c("a", "b", "c"))
```

There is a try-catch as well:

```{r}
xs = c("a", "b", "c")
tot = my_vector_sum(xs)

tot = tryCatch(
  {
    my_vector_sum(xs)
  },
  error = function(e){
    print("xs was non-numeric... coercing xs to numeric...")
    my_vector_sum(as.numeric(as.factor(xs)))
  }
)
tot
```

The recommended thing to do of course is to query if it is non-numeric within the function `my_vector_sum` and cast it then. Possibly create an argument toggling this behavior on/off with a default of off.


## Matrix operations in R

R can do all the standard matrix operations. Let's go through them quickly. First initialize two example matrices:

```{r}
A = matrix(rep(1, 4), nrow = 2)
A
B = array(seq(1, 4), dim = c(2, 2))
B
I = diag(2) #create an identity matrix of size 2x2
I
```

Now we show off some operations:

```{r}
A * B #element-wise multiplication
A %*% B #matrix multiplication
B %*% I
t(B) #transpose
solve(B)
solve(A) #BOOM - why?

#alternative method - to be wrapped in a function
tryCatch(
  {
    solve(A)
  },
  error = function(e){
    print("matrix not invertible, doing Moore-Penrose generalized pseudoinverse instead...")
    MASS::ginv(A)
  }
)

#how would you wrap this and handle it in the real world?
solve(I)
#rank(A) = 1 #no such function... but... there are tons of add-on libraries for matrix computations e.g.
pacman::p_load(Matrix) #load the Matrix library
rankMatrix(B)
rankMatrix(A)
rankMatrix(I)
```

Note that vectors and matrices are not the same:

```{r}
v = c(1, 2, 3) #3-d vector
t(v) #converts to 1x3 vector... unsure why
t(t(v))
v %*% v #seems to default to dot product
t(v) %*% t(t(v)) #dot product
I = diag(3)
I %*% v #seems to default correctly!
I %*% t(v) #actually non-comformable
```

